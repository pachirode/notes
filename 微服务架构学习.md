# 微服务架构设计

### 演变

- 单体架构
    - 所有功能打包到一个容器中运行
    - 一个实例集中了一个系统的所有功能，通过负载均衡实现多实例调用
- `SOA`
    - 提供一种被各个单元或者系统认可的协议进行通讯，实现跨服务的交互能力
        - `SOAP`
        - `REST`
- 微服务
    - 细致拆分的 `SOA`

### 服务划分

##### 规划服务

- 业务
    - 一个需求只会影响一个服务
        - 一个完整的业务流程可能设计多个原子化的业务单元，这些单元应该存放在一个服务中
- 技术
    - 将一些公共服务划分出来
        - 发送邮件
- 领域模型
    - 划分边界模糊的多个服务
- 依赖处理
    - 同层服务之间只有单向依赖
    - 解耦双向依赖服务
        - 直接查询数据
        - 数据冗余
        - 增加一层抽象服务
- 分布式事物
    - 避免产生跨服务的事物处理
    - 如果产生事物，尽量使用 `TCC` 或者基于 `MQ` 的柔性事物而不是 `2PC`
- 性能
    - 特别消耗资源的操作应该尽可能独立
- 服务的稳定性
    - 稳定服务和不稳定服务划分
- 第三方服务调用应该独立
- 调用链
    - 服务之间的调用会消耗 `IO`，需要控制调用链长度

##### 协议

##### 编排

- `ESB`
    - 企业消息总线，有中心化的服务
    - 中心化调度服务以协调各个组件
- 去中心化服务
    - 点对点的通信方式

##### 消息队列

`MQ` 一种用于异步通讯，解耦可靠性传递的中间件
主流的 `MQ` 只有 `RabbitMQ` 支持 `RPC` 方式的请求响应

- 性能
    - `kafka`
- 一致性
    - `RabbitMQ`
- 使用场景
    - 服务的核心调用非核心功能时，非核心失败不影响核心功能
    - 请求耗时长且可以支持回调方式
    - 高可用，一致性保障

##### 调用方式

- `Nginx` 中心化服务
    - 使用类似的反向代理服务来替换服务路由
    - `ESB` 性能问题，调用链拉长
    - 静态配置服务路由实现多实例负载均衡，服务不具备感知功能无法动态调整
- 微服务
    - 各个服务提供服务状态 `API`，定时采集服务信息
    - 对等网络，嵌入式注册和负载
        - 内嵌服务注册和负载调度
    - 独立注册服务，嵌入式负载
        - 独立的中心化服务，各个服务点对点单独调用
        - 所有服务启动之后定时同步服务状态，注册中心有全套路由表，服务定时同步相关路由
- 负载均衡实例调用
    - 随机调用
    - 轮询
        - 将所有服务实例组成循环
    - 加权
        - 响应时间
        - 地区
- 开源注册中心
    - 二次定制
        - `Zookeeper`
        - `Etcd`
    - 直接使用
        - `Consul`
        - `Eureka`

##### 配置中心

- 集群化管理和配置切片
- 版本和审计
- 动态刷新
- 缓存降低依赖

##### 服务熔断

依赖的底层服务会拖累上层服务导致服务发生雪崩
设置每个请求超时时间，达到次数之后不再请求

##### 可降级设置

某个服务或者接口发生较严重的问题，系统可以适配较早版本的服务
并发压力过大，导致整体负载过高

##### 缓存设计

分布式缓存

- 缓存失效
- 缓存穿透
- 缓存一致性
- 热点数据
    - 数据冷热，导致部分缓存节点压力过大

##### 分布式锁

- `Set` 之后的 `MQ` 替代分布式锁
    - 使用用户 `ID` 划分到不同的 `MQ` 队列中，单个队列时单线程
- 乐观锁
- 主流分布式锁
    - 关系数据库
    - `Redis`
    - `Zookeeper`

##### 分布式事务

- 二阶段提交 (`XA` 规范)
    - 提交请求
        - 向所有参与者发送事务提交请求，等待参与者答复
        - 参与者收到提交事务请求
        - 参与者执行事务成功返回同意否则终止
    - 提交
        - 所有参与者都同意
            - 向参与者传递 `commit` 命令
            - 参与者提交，释放本地锁和资源
            - 返回确认
            - 协调器收到所有确认之后完成事务
        - 受到终止
            - 向参与者发送 `rollback` 命令
            - 执行回滚，释放资源
            - 返回确认
            - 回滚结束
- 补偿事务
    - 提交回滚的机制不可用，使用补偿事务撤销失败的事务
    - `Try`
        - 检查业务及资源预处理
    - `Confirm`
        - 确认并执行任务
    - `Cancel`
        - 取消执行的业务，释放资源，可能涉及回滚
- 通知型事务
    - 事务看作消息，使用消息队列来处理

##### 幂等请求

分布式环境对于通讯链路不信任，请求可能需要做重试，需要对接口进行请求去重
`Get` `Put` `Delete` 这些接口要保证幂等，`Post` 不需要，所以前面的接口都要加上 `id`
可以使用状态机进行判断

##### 全局 ID

- 主键自增策略
    - 规划好不同的数据库或者表的体量
    - 使用 `Flick` 算法
- 雪花算法

##### 顺序处理

数据库日志的同步，需要保证所有服务的时钟一致

- 单节点处理
- 单节时序生成
    - 单个节点生成时间，全局记录排序
- `TureTime`
    - 部署多个具有始终同步能力的服务

##### 延迟队列

将处理按照一定要求延迟执行


